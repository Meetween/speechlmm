"""
This script processes a JSONL file containing data about audio files and their transcriptions, tasks, prompts, and AI-generated texts. It reformats the data, extracting instructions and outputs from the generated text based on the task. The extracted information is used to create new JSON objects, which are then written to a new JSONL file.

For each JSON object in the input file, the script creates a new JSON object with the following keys:
- id (int): unique identifier for the audio file
- audio (str): path to the audio file
- task (str): task used to generate the audio file
- instruction (str): instruction generated from the AI model
- output (str): instruction-following output generated by the AI model

There are three tasks: complex_reasoning, detail_description, and conversation. The extraction rules for instruction and output vary based on the task.

For complex_reasoning task:
- Possible formats for generated text include:
  1. "1.<instruction>2.<output>."
  2. "1.<instruction>2.Answer:<output>."
  3. "Question:<instruction>Answer:<output>."

For conversation task:
- Possible formats for generated text include:
  1. "# Question<instruction># Answer<output># Question<instruction># Answer<output>...and so on"
  2. "Question:<instruction>Answer:<output>Question:<instruction>Answer:<output>...and so on"
- A new JSON object is created for each question-answer pair.

For detail_description task:
- The generated text is considered as the output.
- A random sentence from a fixed list of strings is chosen to ask for a detailed description of the audio/speech as the instruction.

Note:
- Each occurnces of "speech transcription" is replaced with "speech".
- After replacing "speech transcription" with "speech", each occurnces of "transcription" is replaced with either "speech" or "audio" (randomly).
"""

import argparse
import json
import random


def process_data(input_file, output_file):
    with open(input_file, "r") as f:
        data = f.readlines()

    new_data = []
    for line in data:
        json_obj = json.loads(line)
        task = json_obj["task"]
        generated_text = json_obj["generated_text"]

        if task == "complex_reasoning":
            instruction, output = extract_complex_reasoning(generated_text)
            instruction, output = remove_transcription(
                instruction
            ), remove_transcription(output)
            new_json_obj = create_json_object(json_obj, instruction, output)
            new_data.append(new_json_obj)
        elif task == "conversation":
            qa_pairs = extract_conversation(generated_text)
            for instruction, output in qa_pairs:
                instruction, output = remove_transcription(
                    instruction
                ), remove_transcription(output)
                new_json_obj = create_json_object(
                    json_obj, instruction, output
                )
                new_data.append(new_json_obj)
        elif task == "detail_description":
            instruction = generate_instruction()
            output = generated_text.strip()
            output = remove_transcription(output)
            new_json_obj = create_json_object(json_obj, instruction, output)
            new_data.append(new_json_obj)

    with open(output_file, "w") as f:
        for line in new_data:
            f.write(json.dumps(line) + "\n")


def remove_transcription(text):
    text = text.replace("speech transcription", "speech")
    text = text.replace("transcription", random.choice(["speech", "audio"]))
    return text


def extract_complex_reasoning(generated_text):
    generated_text = generated_text.replace("\n", "").strip()
    if generated_text.startswith("1."):
        parts = generated_text.split("2.")
        if len(parts) == 2:
            instruction = parts[0][2:].replace("Question:", "").strip()
            output = parts[1].replace("Answer:", "").strip()
            return instruction, output
    elif generated_text.startswith("Question:"):
        parts = generated_text.split("Answer:")
        if len(parts) == 2:
            instruction = parts[0][9:].strip()
            output = parts[1].strip()
            return instruction, output

    # Default case
    return "", ""


def extract_conversation(generated_text):
    generated_text = generated_text.replace("\n", "").strip()
    qa_pairs = []
    # warning: not include the question i+1 in the output i

    if generated_text.startswith("# Question"):
        parts = generated_text.split("#")

        for i in range(1, len(parts), 2):
            parts[i] = parts[i].replace("Question", "")
            instruction = parts[i].strip()
            # check if no answer is provided
            if i + 1 >= len(parts):
                continue
            parts[i + 1] = parts[i + 1].replace("Answer", "")
            output = parts[i + 1].strip()
            qa_pairs.append((instruction, output))
    elif generated_text.startswith("Question:"):
        parts = generated_text.split("Question:")
        for i in range(1, len(parts)):
            qa = parts[i].split("Answer:")
            # check if no answer is provided
            if len(qa) == 2:
                instruction = qa[0]
                output = qa[1].strip()
                qa_pairs.append((instruction, output))

    return qa_pairs


def generate_instruction():
    instructions = [
        "Please provide a detailed description of the speech.",
        "Can you describe the audio in more detail?",
        "We need a detailed description of the speech. Please provide it.",
        "Please provide a detailed description of the audio.",
        "Can you describe the speech in more detail?",
        "What is the speaker talking about?",
        "What is the speaker saying?",
        "What is the speaker discussing?",
        "What is the speech about?",
        "Can you describe the speech?",
    ]
    return random.choice(instructions)


def create_json_object(json_obj, instruction, output):
    new_json_obj = {
        "id": json_obj["id"],
        "audio": json_obj["audio"],
        "task": json_obj["task"],
        "instruction": instruction,
        "output": output,
    }
    return new_json_obj


# main function
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process AI generated data")
    parser.add_argument("-i", type=str, help="Path to the input file")
    parser.add_argument("-o", type=str, help="Path to the output file")
    args = parser.parse_args()

    process_data(args.i, args.o)
